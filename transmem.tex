\documentclass{acm_proc_article-sp}
\usepackage{graphicx}
\usepackage{amssymb}
\bibliographystyle{plain}

\title{Virtualized Transactional Memory}
\author{Zachary Bischof \\
	Northwestern University\\
	Evanston, IL, USA\\
	zbischof@u.northwestern.edu
	\and 
	Marcel Flores \\
	Northwestern University\\
	Evanston, IL, USA\\
	marcel-flores@u.northwestern.edu
	\and
	Maciej Swiech \\
	Northwestern University\\
	Evanston, IL, USA\\
	maciejswiech2007@u.northwestern.edu
	}

\begin{document}
\maketitle

\begin{abstract}
Transactional memory has long been considered as an alternative to locks for
implementing parallel algorithms. In particular, it offers an optimistic
approach to parallelization, and attempts to perform an operation assuming no
contention will occur.

Despite the potential gains of transactional memory, it is only in the 
not-yet-released Haswell architecture from Intel that it has made an appearance.
Palacios has presented us with a unique opportunity to emulate this Intel
implementation in software.

In this paper, we present a basic implementation of transactional memory, which
emulates the Haswell instructions, successfully performing memory transactions.
\end{abstract}

\section{Introduction}
Transactional Memory is pretty cool stuff. We decided to implement it.

\section{Background}
Transactional memory has long been proposed as a solution to the programmatic 
complexity that arises from attempting to use mutual exclusion locks in real world 
implementations of parallel algorithms. We will now consider a basic overview 
of the general idea of transactional memory. We will then go on to describe the
 version that Intel has included in the specifications for the new Haswell 
processors.

\subsection{Transactions}
We define a transaction to be a sequence of memory operations that are 
performed by a processes such that, to all other processes, the operations 
seem to have been performed atomically. Furthermore, the operations must 
appear to the process performing the transaction as having happened one after 
another, with no interference from other processes. When a transaction is finished,
 it either commits the results of its operations to main memory, or it aborts 
the transaction and throws away its changes, depending on the results of a
memory validation.

In order to protect the appearance that the operations have executed serially
without interference, the validation must detect if other processes have 
written to memory that has been used by the transaction. Likewise, in order
to preserve the atomicity, the transaction must not allow other processes
to interfere with the commit. Therefore, the validation must detect if 
other processes have written to memory that is read by the transaction 
(and thereby interfering with the appearance of serial execution), or other 
processes read memory written by the transaction (potentially interfering
with atomicity). Upon an abort, a transaction may decide to attempt to run 
again, or revert to traditional mutex locking mechanisms.~\cite{Herlihy:1993:TMA:173682.165164}

In addition to memory conflicts with other user processes, 
transactions may also be aborted in the event of interrupts, context switches,
or other forced changes in the control flow, as they would violate the
requirement that the transaction happen entirely serially. 

Transactions of this form can be thought of as an optimistic approach to
concurrency, contrasting with the more pessimistic approach of locks. 
Rather than explicitly preventing other processes from accessing memory, the
transaction assumes that it will probably be able to complete unencumbered. If
a conflict does occur, the transaction is able to deal with it accordingly.
Locks, on the other hand, assume that conflicts are likely to occur, and 
directly block other processes from accessing the relevant portions of memory.
Transactions therefor stand to offer a performance gain, as forced 
serialization can be avoided in many cases.

In addition, transactional memory stands to decrease the complexity of 
multi-process applications. Programmers would no longer be weighed down by 
keeping track of which process is holding which locks, and no longer needs
to worry about deadlocks, starvation, and other side effects that can result
from incorrect use of locks.

\subsection{Intel Implementation}

The starting with the Haswell, Intel has inluded the Intel Transactional
Synchronization Extension, which is their implementation of transactional
memory. The extension includes two interfaces: the first is Hardware Lock
Elision, a system designed to work on legacy processors, and of no further
interest to us. The second is Restricted Transactional Memory (RTM). This 
includes instructions for beggining a transactional region (and specifying the
code to run in the event of a failure), aborting a transaction, and ending a 
transactional region. (TODO: Cite the intel manual somewhere near)

The Intel implementation generally follows the design of 
~\cite{Herlihy:1993:TMA:173682.165164}, with a few exceptions.
Most notably, each transaction is only attempted a single time: in the event
of a failure or abort, the code immediatly resorts to the failsafe. 
Additionally, the transactions are checked at a granularity of cache lines, 
rather than actual memory address. In order to validate each transaction at the
time of completion, this implementation stores a read set, the locations of
memory reads from the transaction, and the write set. An abort is triggered
if another processor reads from an address that appears in the write set or 
writes to an address in either set.

Since this is a hardware implementation, transactions may also abort if the 
read and write sets exceed a certain, hardware dependent, capacity. The 
transaction will also be aborted for any numer of instructions that may 
interfere with control flow: such as the writing of control registers, any 
variety of interrupt, processor state changes, TLB control, and so on. The 
specification also suggests that aborts may occur in the case of self modifying
code, or other unpredicable scenarios.

The Intel implementation also offers support for nested paging, however we
save discussion of this topic for later work. (Maybe just don't mention this). 

The Palacios virtual machine manager offers us a unique opportunity to
implement transactional memory which emulates both the original design of
transactional memory, as well as a number of the subtleties observed in 
Intel's implementation.

\section{Palacios Implementation}
In order to implement transactional memory in Palacios, we attempt to follow 
Intel's Haswell specifications, providing us with a consistent interface with which
to use transactions, as well as making future comparisons to direct hardware
implementations easier. We will first consider the high level implementation,
in particular the state machine which governs the functioning of the
transaction. We will then consider the implementation in palacios, and discuss 
a number of the difficulties this implementation presented.  

NOTE: I'm not sure this is the best approach to describing this. Many of the 
decisions made in the design of the machine exist because of the complexity of
trying to get back into the VMM from inside the VM, etc. 

\subsection{State Machine}
In order to keep track of all memory reads and writes during a transaction, 
and to respond accordingly, we use the following state machine:
\begin{enumerate}
\item Begin Transaction
\item ifetch
\item Exec
\item Abort 
\end{enumerate}

- Diagram of the state machine?

- Note what we keep track of

- Undefined exception handler

- Mechanism by which we capture reads and writes

    -General shadow page manipulations

    -Staging page

- Actual trans mem handlers

- Keeping track of other cores

- Various aborts

\section{Design Challenges}
- Shadow paging subtlties

- Code injection

- Register clobbering

\subsection{Current Assumptions}
- AMD

- Decoder limitations

- Assume all activity comes from a single core (will be fixed)

- All memory activity from a transaction fits on a page (with no offset collisions)

- All instructions fit on a page, and overwriting the next instruction can be
done on the same page.

- All interrupts (aside from the obvious ones) are ignorable  

\section{Future Work}

- Fix major assumptions, in particular those related to pages and 
transaction size limitations.

\section{Conclusions}

- The virtual machine is a viable place to implement paradigms that do not yet
exist in hardware

- While by no means fast, in our very limited transaction test space, 
performance was tolerable.

\bibliography{transmem}

\end{document}
